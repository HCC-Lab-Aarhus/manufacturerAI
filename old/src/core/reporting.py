from __future__ import annotations
from pathlib import Path
from typing import Optional
import json

def write_report(
    out_dir: Path, 
    design_spec: Optional[dict] = None,
    pcb_layout: Optional[dict] = None,
    feasibility_report: Optional[dict] = None,
    iterations: int = 0,
    # Legacy parameters for backward compatibility
    params: Optional[object] = None,
    issues: Optional[list[str]] = None
) -> None:
    """
    Write manufacturing report.
    
    Supports both new pipeline format (design_spec, pcb_layout, feasibility_report)
    and legacy format (params, issues).
    """
    lines = []
    lines.append("# Manufacturing Report")
    lines.append("")
    lines.append(f"Generated by ManufacturerAI Pipeline v2")
    lines.append("")
    
    # New pipeline format
    if design_spec:
        lines.append("## Design Specification")
        lines.append("")
        lines.append("```json")
        lines.append(json.dumps(design_spec, indent=2))
        lines.append("```")
        lines.append("")
        
        # Assumptions
        if design_spec.get("assumptions"):
            lines.append("### Assumptions Made")
            for assumption in design_spec["assumptions"]:
                lines.append(f"- {assumption}")
            lines.append("")
    
    if pcb_layout:
        lines.append("## PCB Layout")
        lines.append("")
        component_count = len(pcb_layout.get("components", []))
        button_count = sum(1 for c in pcb_layout.get("components", []) if c["type"] == "button")
        lines.append(f"- Total components: {component_count}")
        lines.append(f"- Buttons: {button_count}")
        lines.append("")
    
    if feasibility_report:
        lines.append("## Feasibility Check")
        lines.append("")
        if feasibility_report["feasible"]:
            lines.append("✓ **Passed** - Layout is manufacturable")
        else:
            lines.append("✗ **Failed** - Layout has issues")
        
        lines.append("")
        lines.append(f"Iterations required: {iterations}")
        lines.append("")
        
        if feasibility_report.get("errors"):
            lines.append("### Errors Found")
            for error in feasibility_report["errors"]:
                lines.append(f"- **{error['code']}**: {error['message']}")
            lines.append("")
        
        if feasibility_report.get("warnings"):
            lines.append("### Warnings")
            for warning in feasibility_report["warnings"]:
                lines.append(f"- {warning['message']}")
            lines.append("")
        
        stats = feasibility_report.get("statistics", {})
        if stats:
            lines.append("### Statistics")
            lines.append(f"- Total components: {stats.get('total_components', 0)}")
            lines.append(f"- Minimum clearance found: {stats.get('min_clearance_found_mm', 0):.2f} mm")
            lines.append("")
    
    # Legacy format support
    if params and issues is not None:
        lines.append("## Legacy Parameters")
        lines.append("")
        lines.append("```json")
        if hasattr(params, 'model_dump_json'):
            lines.append(params.model_dump_json(indent=2))
        else:
            lines.append(json.dumps(params, indent=2))
        lines.append("```")
        lines.append("")
        lines.append("## Validation / Auto-fixes")
        if issues:
            for issue in issues:
                lines.append(f"- {issue}")
        else:
            lines.append("- No issues detected.")
        lines.append("")
    
    lines.append("## Notes")
    lines.append("- PCB layout generated with automatic component placement")
    lines.append("- Enclosure generated parametrically from PCB geometry")
    lines.append("- All artifacts are versioned in the run directory")
    
    (out_dir / "report.md").write_text("\n".join(lines), encoding="utf-8")
    (out_dir / "report.md").write_text("\n".join(lines), encoding="utf-8")
