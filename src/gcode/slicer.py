"""
PrusaSlicer CLI bridge — slices STL models into G-code.

Finds the ``prusa-slicer-console`` executable automatically and invokes
it with a printer profile.  Supports multiple printers (MK3S, Core One+).
All slicing parameters live in ``configs/slicer_profile*.ini``; defaults
are generated on first use.
"""

from __future__ import annotations

import logging
import shutil
import subprocess
from pathlib import Path

log = logging.getLogger("manufacturerAI.gcode.slicer")

# ── Locate PrusaSlicer ─────────────────────────────────────────────

_CANDIDATES = [
    r"C:\Program Files\Prusa3D\PrusaSlicer\prusa-slicer-console.exe",
    r"C:\Program Files (x86)\Prusa3D\PrusaSlicer\prusa-slicer-console.exe",
]


def find_prusaslicer() -> str | None:
    """Return the path to ``prusa-slicer-console``, or *None*."""
    path = shutil.which("prusa-slicer-console")
    if path:
        return path
    for c in _CANDIDATES:
        if Path(c).exists():
            return c
    return None


# ── Printer definitions ────────────────────────────────────────────

from dataclasses import dataclass


@dataclass(frozen=True)
class PrinterDef:
    """Static definition of a supported 3D printer."""
    id: str               # short key, e.g. "mk3s"
    label: str            # human-readable, e.g. "Prusa MK3S"
    bed_width: float      # mm
    bed_depth: float      # mm
    profile_filename: str # ini in configs/


PRINTERS: dict[str, PrinterDef] = {
    "mk3s": PrinterDef(
        id="mk3s",
        label="Prusa MK3S",
        bed_width=250.0,
        bed_depth=210.0,
        profile_filename="slicer_profile.ini",
    ),
    "coreone": PrinterDef(
        id="coreone",
        label="Prusa Core One+",
        bed_width=250.0,
        bed_depth=220.0,
        profile_filename="slicer_profile_coreone.ini",
    ),
}

DEFAULT_PRINTER = "mk3s"


def get_printer(printer_id: str | None = None) -> PrinterDef:
    """Return the *PrinterDef* for *printer_id* (falls back to default)."""
    pid = (printer_id or DEFAULT_PRINTER).lower().strip()
    if pid not in PRINTERS:
        log.warning("Unknown printer '%s' — falling back to %s", pid, DEFAULT_PRINTER)
        pid = DEFAULT_PRINTER
    return PRINTERS[pid]


# ── Default slicer profiles ────────────────────────────────────────

_DEFAULT_PROFILES: dict[str, str] = {
    "slicer_profile.ini": """\
# PrusaSlicer CLI profile — Prusa MK3S, PLA, 0.2 mm layers
# Generated by ManufacturerAI — edit freely.

# --- Printer ---
printer_model = MK3S
gcode_flavor = marlin
bed_shape = 0x0,250x0,250x210,0x210
nozzle_diameter = 0.4
start_gcode = M862.3 P \\"MK3S\\" ; printer model check\\nM862.1 P0.4 ; nozzle diameter check\\nM115 U3.14.0 ; tell printer latest fw version\\nG28 W ; home all without mesh bed level\\nG80 ; mesh bed leveling\\nG1 Z0.20 F720\\nG1 Y-3 F1000 ; go outside print area\\nG92 E0\\nG1 X60 E9 F1000 ; intro line\\nG1 X100 E12.5 F1000 ; intro line\\nG92 E0\\nM221 S95
end_gcode = G4 ; wait\\nM104 S0 ; turn off temperature\\nM140 S0 ; turn off heatbed\\nM107 ; turn off fan\\nG1 X0 Y200 ; home X axis\\nM84 ; disable motors

# --- Print ---
layer_height = 0.2
first_layer_height = 0.2
perimeters = 3
top_solid_layers = 4
bottom_solid_layers = 3
fill_density = 15%
fill_pattern = grid
infill_speed = 60
perimeter_speed = 45
travel_speed = 150

# --- Temperatures ---
temperature = 215
first_layer_temperature = 215
bed_temperature = 60
first_layer_bed_temperature = 60

# --- Retraction ---
retract_length = 0.8
retract_speed = 35
retract_lift = 0.6

# --- Cooling ---
fan_always_on = 1
min_fan_speed = 100
max_fan_speed = 100
bridge_fan_speed = 100

# --- Support ---
support_material = 1
support_material_buildplate_only = 1
support_material_pattern = grid
support_material_spacing = 2.5
support_material_contact_distance = 0.2
support_material_xy_spacing = 50%

# --- Ironing ---
ironing = 1
ironing_type = top
ironing_flowrate = 15%
ironing_speed = 15
ironing_spacing = 0.1
""",
    "slicer_profile_coreone.ini": """\
# PrusaSlicer CLI profile — Prusa Core One+, PLA, 0.2 mm layers
# Generated by ManufacturerAI — edit freely.

# --- Printer ---
printer_model = COREONE
gcode_flavor = marlin2
bed_shape = 0x0,250x0,250x220,0x220
nozzle_diameter = 0.4
printer_notes = PRINTER_HAS_INPUT_SHAPER;PRINTER_MODEL_COREONE;
machine_limits_usage = emit_to_gcode
start_gcode = M862.3 P \\"COREONE\\" ; printer model check\\nM862.1 P0.4 ; nozzle diameter check\\nG28 ; home all axes\\nG29 ; mesh bed leveling\\nG1 Z0.20 F720\\nG1 Y-3 F1000 ; go outside print area\\nG92 E0\\nG1 X60 E9 F1000 ; intro line\\nG1 X100 E12.5 F1000 ; intro line\\nG92 E0\\nM221 S95
end_gcode = G4 ; wait\\nM104 S0 ; turn off temperature\\nM140 S0 ; turn off heatbed\\nM107 ; turn off fan\\nG1 X0 Y210 ; home X axis\\nM84 ; disable motors
thumbnails = 16x16,220x124

# --- Print ---
layer_height = 0.2
first_layer_height = 0.2
perimeters = 3
top_solid_layers = 4
bottom_solid_layers = 3
fill_density = 15%
fill_pattern = grid
infill_speed = 200
solid_infill_speed = 200
top_solid_infill_speed = 15
perimeter_speed = 150
external_perimeter_speed = 100
small_perimeter_speed = 50
gap_fill_speed = 40
first_layer_speed = 30
travel_speed = 400
max_print_speed = 250

# --- Acceleration (Core One+ with Input Shaper) ---
perimeter_acceleration = 5000
infill_acceleration = 5000
solid_infill_acceleration = 5000
top_solid_infill_acceleration = 2000
first_layer_acceleration = 1000
travel_acceleration = 5000
default_acceleration = 5000

# --- Temperatures ---
temperature = 215
first_layer_temperature = 215
bed_temperature = 60
first_layer_bed_temperature = 60

# --- Retraction ---
retract_length = 0.8
retract_speed = 35
retract_lift = 0.6

# --- Cooling ---
fan_always_on = 1
min_fan_speed = 100
max_fan_speed = 100
bridge_fan_speed = 100

# --- Support ---
support_material = 1
support_material_buildplate_only = 1
support_material_pattern = grid
support_material_spacing = 2.5
support_material_contact_distance = 0.2
support_material_xy_spacing = 50%
support_material_speed = 100

# --- Ironing ---
ironing = 1
ironing_type = top
ironing_flowrate = 15%
ironing_speed = 15
ironing_spacing = 0.1
""",
}


def ensure_profile(profile_path: Path) -> Path:
    """Create a slicer profile if it doesn't exist yet."""
    if not profile_path.exists():
        profile_path.parent.mkdir(parents=True, exist_ok=True)
        default_content = _DEFAULT_PROFILES.get(profile_path.name, "")
        if default_content:
            profile_path.write_text(default_content, encoding="utf-8")
            log.info("Created default slicer profile: %s", profile_path)
        else:
            log.warning("No default content for profile %s", profile_path.name)
    return profile_path


# ── Slice ──────────────────────────────────────────────────────────

def slice_stl(
    stl_path: Path,
    output_gcode: Path | None = None,
    profile_path: Path | None = None,
    *,
    printer: str | None = None,
    timeout_s: int = 300,
) -> tuple[bool, str, Path | None]:
    """Slice *stl_path* and write G-code.

    Parameters
    ----------
    stl_path : Path
        Input STL file.
    output_gcode : Path, optional
        Where to write the ``.gcode`` file.  Defaults to
        ``stl_path.with_suffix('.gcode')``.
    profile_path : Path, optional
        ``--load`` ini file.  When *None* the printer-specific
        default profile is used (created if missing).
    printer : str, optional
        Printer id (``"mk3s"`` or ``"coreone"``).  Determines which
        default profile to use when *profile_path* is None.
    timeout_s : int
        CLI timeout in seconds.

    Returns
    -------
    (ok, message, gcode_path_or_none)
    """
    exe = find_prusaslicer()
    if not exe:
        return False, "PrusaSlicer not found on this system.", None

    if profile_path is None:
        pdef = get_printer(printer)
        cfg_dir = Path(__file__).resolve().parents[2] / "configs"
        profile_path = ensure_profile(cfg_dir / pdef.profile_filename)

    if output_gcode is None:
        output_gcode = stl_path.with_suffix(".gcode")

    cmd = [
        exe,
        "--export-gcode",
        "--load", str(profile_path),
        "--output", str(output_gcode),
        str(stl_path),
    ]

    log.info("Slicing: %s", " ".join(cmd))

    try:
        result = subprocess.run(
            cmd,
            capture_output=True,
            text=True,
            timeout=timeout_s,
        )
        stderr = result.stderr.strip()
        if result.returncode == 0 and output_gcode.exists():
            log.info("Slicing succeeded: %s", output_gcode)
            return True, stderr or "OK", output_gcode
        return False, stderr or f"PrusaSlicer exited with code {result.returncode}", None
    except subprocess.TimeoutExpired:
        return False, f"PrusaSlicer timed out ({timeout_s}s).", None
    except Exception as e:
        return False, str(e), None
